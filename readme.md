# Logic Expression Compiler

## Experiment Contents

​	The input is a logical expression containing a number, and the output is the boolean value after calculation and the number of comparisons skipped due to short-circuit operations. The output format is "Output: [true or false], [number of times]". Note that the evaluation of the logical expression conforms to the short-circuit algorithm. Among them, the operater "!" counts the number of logical operations, and "==" or "!=" are only used for non-boolean numeric comparisons.

## Lexical Analysis

​		Flex is an open source lexical analyzer. The compiler converts the pattern input by the developer into a state transition diagram, and generates the corresponding implementation code, which is stored in the .yy, c files.

| token | symbol                | meaning    |
| ----------- | ------------------- | -------- |
| dight       | [0-9]\|\[1-9][0-9]* | number     |
| LT          | <                   | less than    |
| GT          | >                   | greater than  |
| LE          | <=                  | less or equal to |
| GE          | >=                  | greater or equal to |
| EQ          | ==                  | equal to     |
| NE          | !=                  | not equal to   |
| AND         | &&                  | and     |
| OR          | \|\|                | or     |
| NOT         | !                   | not    |
| LP          | (                   | left parentheses  |
| RP          | )                   | right parentheses   |
| newline     | \n\r                | line-termination |
| whitespace  | \t\f\v              | whitespace   |

## Grammar Analysis

#### Bison

​	By using bison and flex together, it can convert the grammar rules provided by the user into a parser, read the productions of the grammar provided by the user, generate a LALR(1) action table in C language format, and include it in a C function named yyparse. The function of yyparse is to use this action table to parse the token stream, and the token stream is obtained by scanning the source program by the lexical analyzer generated by flex.

​		In bison, ":" represents a "->", different productions of the same non-terminal symbol are separated by "|", and the end with ";" indicates the end of a non-terminal symbol production; each production is followed by a curly bracket is a piece of C code that will be executed when the production is applied. This code is called an action. Comments can be inserted between the production and inside the C code (more on this code in this document later) ; When the right-hand side of the production is ε, there is no need to write any symbol, and a comment /* empty */ is generally used instead.

​ bison treats the nonterminal symbol on the left of the first production in the Productions section (Program in this document) as the start symbol of the grammar, and, to ensure that the start symbol is not on the right side of any production, bison will automatically generate the augmented grammar, and the newly added symbol is used as the starting symbol for parsing.

#### Grammatical precedence and associativity

​		The precedence and associativity of these operator tokens are defined in the .y file. In the code, the first declaration has a lower precedence, and the tokens declared at the same time have the same precedence. The rules are as follows:

| Priority(top-down） | simbol        | Associativity |
| ------------------ | ----------- | ------ |
| 1                  | OR          | Left |
| 2                  | AND         | Left |
| 3                  | LT GT LE GE | Left |
| 4                  | EQ NE       | Left |
| 5                  | NOT         | Right  |
| 6                  | LP RP       | Left |

#### Grammar Design

​		According to the form of logical expressions, the following grammar is summarized:

● Program => Exp

● Exp => NOT Exp 

​				| Exp AND Exp

​				| Exp OR Exp

​				| Exp LT Exp

​				| Exp LE Exp

​				| Exp GT Exp

​				| Exp GE Exp

​				| Exp EQ Exp

​				| Exp NE Exp

​				| LP Exp Rp

​				| VALUE

​		Program is the start symbol of the grammar, and the corresponding augmented grammar Program' will be automatically generated after bison compilation.

#### Records of short circuit times

​		The number of short circuits is only relevant to the AND and OR operators. First, in the .y file, define a global variable to count the number of short circuits:

```c
int short_cut = 0;	// record the number of shortcuts 
```

​		对于AND，如果第一个表达式的结果为False，则进行短路，short_cut值自增1，返回为True；对于OR，如果第一个表达式的结果为True，则进行短路，short_cut值自增1，返回为True。其他情况不考虑短路操作，短路操作对应的部分代码如下：

```c
	| Exp AND Exp {			// AND operation
		if ( $1 == 0 ) {	// The first operand is False, so short-circuit
			short_cut++;
			$$ = 0;
		}
		else
		{
			if ($3 == 1) { $$ = 1; }
			else { $$ = 0; }
		}
	}
	| Exp OR Exp {  	// OR operation
		if ($1 == 1) {	// The first operand is True, so short-circuit
			short_cut++;
			$$ = 1;
		}
		else {
			if ($3 == 0) { $$ = 0; }
			else { $$ = 1; }
		}
	}
```

#### Error Handling

​   All input symbols accepted by the program are as follows:	

```c
%token LT 	// <
%token GT	// >
%token LE	// <=
%token GE	// >=
%token EQ	// ==
%token NE	// !=
%token AND	// &&
%token OR	// ||
%token NOT	// !
%token LP	// (
%token RP	// )
digit	[0-9]|[1-9][0-9]*	// Numbers
whitespace [ \t\f\v]		// Whitespace
newline [\r\n]  		// Newline
```

​		当输入的字符不在上述列表中时，程序输出错误信息，并显示第一个输入错误的字符内容。当有多个错误时，只会显示第一个错误，检测到错误就立即停止运行。代码如下：

```c
/* error, incorrect character */
.	{
	// 输入遇到非指定字符,显示出错,则不再继续分析
	printf("Error! Wrong token '%s'.\n", yytext);
	exit(0);
}
```

## compilation and Runtime output

#### Compile outputs

​	Compile files:

![image](https://user-images.githubusercontent.com/51059802/141681513-23490951-2a6d-4ee0-baf3-efb18b47e51a.png)


​	Compile succeeds, generates files listed below：

![image](https://user-images.githubusercontent.com/51059802/141681523-6cef240e-f386-424b-8f52-474f81df7880.png)

#### Operation Result

​		Test program output：

![image](https://user-images.githubusercontent.com/51059802/141681534-02133267-d6d4-4a26-863b-588194d1402b.png)
![image](https://user-images.githubusercontent.com/51059802/141681543-4c243239-63b0-4802-b207-c26f251f450b.png)
![image](https://user-images.githubusercontent.com/51059802/141681548-466a0752-c626-4720-a66b-bc988123adf8.png)

​		Let's test some illegal grammars：

![image](https://user-images.githubusercontent.com/51059802/141681564-b0f92f78-0a4b-4700-8b13-c61cb7f88a74.png)

​		The program works as expected.
